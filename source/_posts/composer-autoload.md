---
title: composer autoload
categories: php
date: 2017-03-02 00:05:52
---


> 在引用各种组件时，常常只知道composer require  xxx/xxx，就能使用第三方库的类。对于vender下是如何包含我们需要的类了解不清。
> vender/composer 文件夹怎么来的？有什么作用？具体流程怎么处理的？

* 为何引入vendor/autoload.php
> autoload.php 承担代理真实处理 返回一个自动加载器 类似入口文件
	
		<?php
		// autoload.php @generated by Composer  Composer自动生成
		require_once __DIR__ . '/composer' . '/autoload_real.php'; //引入真实的自动加载文件
		return ComposerAutoloaderInite126e603acf96df70971f26ca865db57::getLoader();
		//调用getLoader方法  这里会返回一个自动加载的类并注册到自动加载队列中
		
<!--more-->
* autoload_real
> 文件包含一个静态变量$loader 这个保存自动加载器
> loadClassLoader方法在getLoader 中，是为了包含ClassLoader.php文件 这是真正的自动加载器文件
> getLoader 通过一系列逻辑之后返回自动加载器
> autoload_static 采用匿名函数给ClassLoader 的属性绑定值
> namespace classMap 采用ClassLoader的方式直接给属性赋值

		<?php   

		// autoload_real.php @generated by Composer 

		class ComposerAutoloaderInite126e603acf96df70971f26ca865db7
		{
    	private static $loader;

    	public static function loadClassLoader($class)
    	{
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    	}

    	public static function getLoader()
    	{
        if (null !== self::$loader) {
            return self::$loader;
       

    	}
       
            spl_autoload_register(array('ComposerAutoloaderInite126e603acf96df70971f26ca865db57', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        spl_autoload_unregister(array('ComposerAutoloaderInite126e603acf96df70971f26ca865db57', 'loadClassLoader'));
		//上main就是为了 new \Composer\Autoload\ClassLoader()的时候自动包含文件
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION');
        //php版本大于5.6或者是HHVM 使用autoload_static 初始化自动加载器
        if ($useStaticLoader) {
            require_once __DIR__ . '/autoload_static.php';

            call_user_func(\Composer\Autoload\ComposerStaticInite126e603acf96df70971f26ca865db57::getInitializer($loader));
        } else {
        //否则使用autoload_namespace ...初始化加载器
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }

            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }

        $loader->register(true);
			//注册自动加载器
        return $loader;
    	}
    	
    	
* composer dumpautoload
> vender/composer下的文件都是composer 根据初始的composer.json配置生成的
> 生成的autoload_classmap nameapce psr4 对应classmap psr4等声明方式

		vender/monolog/composer.json
		"autoload": {
        "psr-4": {"Monolog\\": "src/Monolog"}
    	},
    	
    	vender/psr/composer.json
    	  "autoload": {
        "psr-4": {
            "Psr\\Log\\": "Psr/Log/"
        }
    	}
    	
    	vender/composer/autoload_psr4.php
    	return array(
    	'Psr\\Log\\' => array($vendorDir . '/psr/log/Psr/Log'),
    	'Monolog\\' => array($vendorDir . '/monolog/monolog/src/Monolog'),
		);
		
		vender/composer/autoload_static.php
		  public static $prefixDirsPsr4 = array (
        'Psr\\Log\\' => 
        array (
            0 => __DIR__ . '/..' . '/psr/log/Psr/Log',
        ),
        'Monolog\\' => 
        array (
            0 => __DIR__ . '/..' . '/monolog/monolog/src/Monolog',
        ),
    	);
    	
* ClassLoader.php
> ClassLoader.php 实现查找文件并包含文件的功能
> findFile 方法实现查找文件
    	

